#include <iostream>
#include <vector>
#include <random>
#include <chrono>
using namespace std;

class NQueensSolver {
private:

    // used for when we want to calculate the queen with max conflicts - since she participates once in each of the vectors
    // rows, primaryDiagonals and secondaryDiagonals, we need to subtract each increment to get the real number of conflicts
    const int QUEEN_CONFLICTS_OFFSET = 3;
    const int K = 3; // used for the number of steps the algorithm minConflicts() performs
    int numberOfQueens; // the number of queens and therefore the size of the board
    vector<int> queenRowPositions; // index: the index of the queen, value: the row position of that queen
    vector<int> rows; // the number of queens on each row
    vector<int> primaryDiagonals; // the number of queens on each primary diagonal on the board
    vector<int> secondaryDiagonals; // the number of queens on each secondary diagonal on the board
    vector<int> conflictRowsBuffer; // used for storing the queens with max conflicts and the rows with min conflicts
    random_device rd; // used to obtain a seed for the random number engine
    mt19937 randomNumberGenerator; // standard marsenne_twister_engine seeded with rd()

    // uniform_int_distribution - used to transform the random unsigned int generated by randomNumberGenerator into an int in [0, to]
    int getRandomIndex(int to) {
        return uniform_int_distribution<>(0, to)(randomNumberGenerator);
    }

    // having the rowIndex and the columnIndex of a tile, determine the primary diagonal it is on (we need to offset it with
    // (numberOfQueens - 1) since in some cases columnIndex < rowIndex, and therefore we will get a negative index)
    int getPrimaryDiagonalIndex(const int& rowIndex, const int& columnIndex) {
        return columnIndex - rowIndex + numberOfQueens - 1;
    }

    // having the rowIndex and the columnIndex of a tile, determine the secondary diagonal it is on
    int getSecondaryDiagonalIndex(const int& rowIndex, const int& columnIndex) {
        return columnIndex + rowIndex;
    }

    // determine the amount of conflicts the tile which is positioned on [rowIndex; columnIndex] has by looking at how many
    // queens reside on the current row, on the current primary diagonal and on the current secondary diagonal
    int getConflicts(const int& rowIndex, const int& columnIndex) {
        return rows[rowIndex] + primaryDiagonals[getPrimaryDiagonalIndex(rowIndex, columnIndex)] +
            secondaryDiagonals[getSecondaryDiagonalIndex(rowIndex, columnIndex)];
    }

    // when a queen is moved, increment the corresponding row, primary diagonal and secondary diagonal, so that they "know" she is there
    void updateNumberOfConflicts(const int& row, const int& queenIndex) {
        rows[queenRowPositions[queenIndex]]++;
        primaryDiagonals[getPrimaryDiagonalIndex(row, queenIndex)]++;
        secondaryDiagonals[getSecondaryDiagonalIndex(row, queenIndex)]++;
    }

    // when a queen is moved, decrement the old row, primary diagonal and secondary diagonal the queen resided on, so that they "know"
    // she has moved away from that position
    void removeOldConflicts(const int& row, const int& queenIndex) {
        rows[queenRowPositions[queenIndex]]--;
        primaryDiagonals[getPrimaryDiagonalIndex(queenRowPositions[queenIndex], queenIndex)]--;
        secondaryDiagonals[getSecondaryDiagonalIndex(queenRowPositions[queenIndex], queenIndex)]--;
    }

    // when we move a queen, we first decrement the values of the old row, primary diagonal  and secondary diagonal,
    // then we update her position and finally, we increment the values of the new row, primary diagonal and secondary diagonal
    void moveQueen(const int& row, const int& queenIndex) {
        removeOldConflicts(row, queenIndex);
        queenRowPositions[queenIndex] = row;
        updateNumberOfConflicts(row, queenIndex);
    }

    pair<int, int> getMaxConflictQueen() {
        int maxConflicts = -1, maxConflictsQueenCount = 0;
        for (int columnIndex = 0; columnIndex < numberOfQueens; columnIndex++) {
            // get the number of conflicts of the queen with index columnIndex
            int currentConflicts = getConflicts(queenRowPositions[columnIndex], columnIndex);

            // if we encountered a bigger number of conflicts
            if (maxConflicts < currentConflicts) {
                maxConflicts = currentConflicts;
                maxConflictsQueenCount = 0; // restart the buffer anew in case we have multiple queens there with the same number of conflicts which up until now was maximum
                conflictRowsBuffer[maxConflictsQueenCount++] = columnIndex;
            }
            else if (maxConflicts == currentConflicts) {
                conflictRowsBuffer[maxConflictsQueenCount++] = columnIndex; // just append the queen to the buffer
            }
        }

        // since we check for the number of conflicts on the position of each queen, we will count the same queen three times:
        // once from the rows vector, once from the primaryDiagonals vector and once from the secondaryDiagonals vector
        // now since we don't need to count the number of conflicts with herself, we need to offset the value we got with -3
        // note that it does not matter if we do it here or during the calculation in the for loop
        return { conflictRowsBuffer[getRandomIndex(maxConflictsQueenCount - 1)], maxConflicts - QUEEN_CONFLICTS_OFFSET };
    }

    int getMinConflictRow(const int queenIndex) {
        int minConflicts = INT_MAX, minConflictsQueenCount = 0, currentConflicts;
        for (int rowIndex = 0; rowIndex < numberOfQueens; rowIndex++) {
            if (rowIndex == queenRowPositions[queenIndex]) { // if the row we are looking at has a queen, we need to offset the number of conflicts with -3
                currentConflicts = getConflicts(rowIndex, queenIndex) - QUEEN_CONFLICTS_OFFSET;
            }
            else {
                currentConflicts = getConflicts(rowIndex, queenIndex);
            }

            if (minConflicts > currentConflicts) {
                minConflicts = currentConflicts;
                minConflictsQueenCount = 0;
                conflictRowsBuffer[minConflictsQueenCount++] = rowIndex;
            }
            else if (minConflicts == currentConflicts) {
                conflictRowsBuffer[minConflictsQueenCount++] = rowIndex;
            }
        }

        return conflictRowsBuffer[getRandomIndex(minConflictsQueenCount - 1)];
    }

    // used when we are in the initialization function, this function behaves like moveQueen(), only that it does not decrement the previous
    // position of the queen from the vectors rows, primaryDiagonals and secondaryDiagonals, because in the initialization, the queen did not have
    // a previous position
    void placeQueen(const int row, const int queenIndex) {
        queenRowPositions[queenIndex] = row;
        updateNumberOfConflicts(row, queenIndex);
    }

    void initialise() {
        fill(rows.begin(), rows.end(), 0);
        fill(primaryDiagonals.begin(), primaryDiagonals.end(), 0);
        fill(secondaryDiagonals.begin(), secondaryDiagonals.end(), 0);

        // initialize using the min conflicts algorithm
        /*
        placeQueen(getRandomIndex(numberOfQueens - 1), 0);

        for (int column = 1; column < numberOfQueens; column++) {
            int chosenRowIndex = getMinConflictRow(column);
            placeQueen(chosenRowIndex, column);
        }
         */

         // initialize using the horse's movement
        int currentCol = 1;
        for (int row = 0; row < numberOfQueens; row++) {
            placeQueen(row, currentCol);
            currentCol += 2;
            if (currentCol >= numberOfQueens) {
                currentCol = 0;
            }
        }
    }

    bool minConflicts() {
        int upperBound = numberOfQueens * K; // defines the number of loops the for loop is going to do (avoiding cycles)
        pair<int, int> maxConflictsQueen;
        for (int i = 0; i < upperBound; i++) {
            maxConflictsQueen = getMaxConflictQueen(); // get the queen with maximum number of conflicts

            if (maxConflictsQueen.second == 0) { // if the maximum number of conflicts was 0, then we have found a solution
                return true;
            }

            // get the row with the minimum number of conflicts -
            // we are only testing the tiles that have a column index the index of the queen with maximum number of conflicts
            int minConflictsRow = getMinConflictRow(maxConflictsQueen.first);

            // place the queen on that row
            moveQueen(minConflictsRow, maxConflictsQueen.first);
        }

        return false;
    }

    void printChessBoard() {
        for (int rowIndex = 0; rowIndex < numberOfQueens; rowIndex++) {
            for (int i = 0; i < numberOfQueens; i++) {
                if (queenRowPositions[i] == rowIndex) {
                    cout << "*";
                }
                else {
                    cout << "_";
                }

                if (i != numberOfQueens - 1) {
                    cout << " ";
                }
            }
            cout << endl;
        }
    }

public:

    NQueensSolver(int numberOfQueens) {
        this->numberOfQueens = numberOfQueens;
        queenRowPositions = vector<int>(numberOfQueens, 0);
        rows = vector<int>(numberOfQueens);
        primaryDiagonals = vector<int>(2 * numberOfQueens - 1);
        secondaryDiagonals = vector<int>(2 * numberOfQueens - 1);
        conflictRowsBuffer = vector<int>(numberOfQueens);
        randomNumberGenerator = mt19937(rd());
    }

    void solve() {
        if (numberOfQueens == 1) {
            cout << "Q" << endl;
            return;
        }

        if (numberOfQueens == 2 || numberOfQueens == 3) {
            cout << "No solution exists!" << endl;
            return;
        }

        initialise();

        while (!minConflicts()) {
            initialise(); // restart
        }

        if (numberOfQueens < 50) {
            printChessBoard();
        }
    }
};

int main() {
    int numberOfQueens;
    cin >> numberOfQueens;

    auto begin = chrono::steady_clock::now();
    NQueensSolver* solver = new NQueensSolver(numberOfQueens);
    solver->solve();
    auto end = chrono::steady_clock::now();
    long long elapsedTimeInMilliseconds = chrono::duration_cast<chrono::milliseconds>(end - begin).count();
    cout << "Time (in milliseconds): " << elapsedTimeInMilliseconds << "ms." << endl;
    cout << "Time (in seconds): " << elapsedTimeInMilliseconds / 1000.0 << "s." << endl;

    delete solver;
    return 0;
}
